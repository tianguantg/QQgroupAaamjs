<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ‰«ğŸ·å¤§ä½œæˆ˜</title>
    <style>
        :root {
            --bg-color: #fce4ec;
            --board-bg: #8d6e63;
            --cell-closed: #a1887f;
            --cell-open: #efebe9;
            --highlight: #f8bbd0;
            --text-color: #4e342e;
            --shadow-light: rgba(255, 255, 255, 0.3);
            --shadow-dark: rgba(0, 0, 0, 0.2);
        }

        * {
            box-sizing: border-box;
            user-select: none; /* ç¦æ­¢æ–‡å­—é€‰ä¸­ */
            -webkit-tap-highlight-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        header {
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .status-box {
            text-align: center;
            font-weight: bold;
        }

        .status-label {
            font-size: 12px;
            color: #888;
        }

        .status-value {
            font-size: 20px;
        }

        .emoji-btn {
            font-size: 28px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .emoji-btn:active {
            transform: scale(0.9);
        }

        /* æ¸¸æˆä¸»åŒºåŸŸ */
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            padding: 20px;
            background-color: var(--bg-color);
        }

        #grid {
            display: grid;
            gap: 2px;
            background-color: var(--board-bg);
            padding: 4px;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .cell {
            width: 34px; /* é»˜è®¤å¤§å°ï¼ŒJSä¼šåŠ¨æ€è°ƒæ•´ */
            height: 34px;
            background-color: var(--cell-closed);
            border-radius: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.1s;
            box-shadow: inset 2px 2px 0 var(--shadow-light), inset -2px -2px 0 var(--shadow-dark);
        }

        .cell.open {
            background-color: var(--cell-open);
            box-shadow: none;
            border: 1px solid #d7ccc8;
        }

        .cell.flagged {
            font-size: 16px;
        }

        /* æ•°å­—é¢œè‰² */
        .c1 { color: #1976D2; }
        .c2 { color: #388E3C; }
        .c3 { color: #D32F2F; }
        .c4 { color: #7B1FA2; }
        .c5 { color: #FF8F00; }
        .c6 { color: #0097A7; }
        .c7 { color: #424242; }
        .c8 { color: #8D6E63; }

        /* åº•éƒ¨æ§åˆ¶æ  */
        footer {
            padding: 15px;
            background: #fff;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
        }

        .mode-btn {
            padding: 8px 16px;
            border: 2px solid var(--board-bg);
            border-radius: 20px;
            background: transparent;
            color: var(--board-bg);
            font-weight: bold;
            font-size: 14px;
        }

        .mode-btn.active {
            background: var(--board-bg);
            color: #fff;
        }

        /* å¼¹çª—é®ç½© */
        #overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(2px);
        }

        #overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: white;
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            width: 80%;
            max-width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transform: scale(0.8);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #overlay.visible .modal {
            transform: scale(1);
        }

        .modal h2 { margin-top: 0; color: var(--text-color); }
        .modal p { color: #666; margin-bottom: 20px; }

        .restart-btn {
            background: var(--board-bg);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(141, 110, 99, 0.4);
        }
        
        /* æç¤ºå±‚ */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .toast.show { opacity: 1; }

    </style>
</head>
<body>

    <header>
        <div class="status-box">
            <div class="status-label">å‰©ä½™çŒªçŒª</div>
            <div class="status-value" id="mine-count">000</div>
        </div>
        <div class="emoji-btn" id="face-btn">ğŸ˜Š</div>
        <div class="status-box">
            <div class="status-label">è€—æ—¶</div>
            <div class="status-value" id="timer">000</div>
        </div>
    </header>

    <div id="game-container">
        <div id="grid"></div>
    </div>

    <div class="toast" id="toast">é•¿æŒ‰æ–¹å—æ’æ——ï¼Œç‚¹å‡»ç¿»å¼€</div>

    <footer>
        <button class="mode-btn active" onclick="setDifficulty('easy')">ç®€å• (9x9)</button>
        <button class="mode-btn" onclick="setDifficulty('medium')">ä¸­ç­‰ (12x12)</button>
        <button class="mode-btn" onclick="setDifficulty('hard')">å›°éš¾ (12x20)</button>
    </footer>

    <div id="overlay">
        <div class="modal">
            <h2 id="modal-title">æ¸¸æˆç»“æŸ</h2>
            <p id="modal-msg">ä½ è¸©åˆ°çŒªçŒªäº†ï¼</p>
            <button class="restart-btn" onclick="resetGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // é…ç½®
        const CONFIG = {
            easy: { rows: 9, cols: 9, mines: 10 },
            medium: { rows: 12, cols: 12, mines: 20 },
            hard: { rows: 20, cols: 12, mines: 35 } // ç«–å±é€‚é…ï¼Œè¡Œå¤šåˆ—å°‘
        };

        let currentDiff = 'easy';
        let grid = []; // æ•°æ®å±‚
        let gameActive = false;
        let flags = 0;
        let time = 0;
        let timerInterval;
        let isFirstClick = true;
        let longPressTimer;
        
        // DOM å…ƒç´ 
        const gridEl = document.getElementById('grid');
        const mineCountEl = document.getElementById('mine-count');
        const timerEl = document.getElementById('timer');
        const faceBtn = document.getElementById('face-btn');
        const overlay = document.getElementById('overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMsg = document.getElementById('modal-msg');
        const toast = document.getElementById('toast');

        // åˆå§‹åŒ–
        function init() {
            // ç¦ç”¨å³é”®èœå•
            window.oncontextmenu = (e) => {
                e.preventDefault();
                e.stopPropagation();
                return false;
            };

            setDifficulty('easy');
            showToast();
        }

        function setDifficulty(diff) {
            currentDiff = diff;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.innerText.includes(diff === 'easy' ? 'ç®€å•' : diff === 'medium' ? 'ä¸­ç­‰' : 'å›°éš¾')) {
                    btn.classList.add('active');
                }
            });
            resetGame();
        }

        function resetGame() {
            clearInterval(timerInterval);
            time = 0;
            timerEl.innerText = '000';
            gameActive = true;
            isFirstClick = true;
            faceBtn.innerText = 'ğŸ˜Š';
            overlay.classList.remove('visible');
            
            const { rows, cols, mines } = CONFIG[currentDiff];
            flags = mines;
            updateMineCount();

            // åŠ¨æ€è®¡ç®—æ ¼å­å¤§å°ä»¥é€‚åº”å±å¹•
            const maxWidth = document.getElementById('game-container').clientWidth - 40;
            const cellSize = Math.floor(maxWidth / cols);
            
            gridEl.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            gridEl.innerHTML = '';
            grid = [];

            // ç”Ÿæˆç½‘æ ¼
            for (let r = 0; r < rows; r++) {
                const row = [];
                for (let c = 0; c < cols; c++) {
                    const cell = {
                        r, c,
                        isMine: false,
                        isOpen: false,
                        isFlagged: false,
                        element: null,
                        neighbors: 0
                    };
                    
                    const el = document.createElement('div');
                    el.className = 'cell';
                    el.style.width = `${cellSize}px`;
                    el.style.height = `${cellSize}px`;
                    el.style.fontSize = `${cellSize * 0.6}px`; // åŠ¨æ€å­—ä½“
                    
                    // è§¦æ‘¸/ç‚¹å‡»äº‹ä»¶ç»‘å®š
                    bindEvents(el, r, c);

                    cell.element = el;
                    row.push(cell);
                    gridEl.appendChild(el);
                }
                grid.push(row);
            }
        }

        function bindEvents(el, r, c) {
            // å…¼å®¹è§¦æ‘¸å’Œé¼ æ ‡
            const handleStart = (e) => {
                if (!gameActive || grid[r][c].isOpen) return;
                
                // é•¿æŒ‰é€»è¾‘
                longPressTimer = setTimeout(() => {
                    toggleFlag(r, c);
                    longPressTimer = null;
                    if (navigator.vibrate) navigator.vibrate(50); // éœ‡åŠ¨åé¦ˆ
                }, 400); // 400ms ç®—é•¿æŒ‰
            };

            const handleEnd = (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    // å¦‚æœä¸æ˜¯é•¿æŒ‰ï¼Œåˆ™è§†ä¸ºç‚¹å‡»
                    handleClick(r, c);
                }
                e.preventDefault(); // é˜²æ­¢è§¦å‘é»˜è®¤ç‚¹å‡»
            };

            el.addEventListener('touchstart', handleStart, {passive: false});
            el.addEventListener('touchend', handleEnd, {passive: false});
            el.addEventListener('mousedown', (e) => {
                if(e.button === 0) handleStart(e);
                if(e.button === 2) toggleFlag(r, c); // å³é”®ç›´æ¥æ’æ——
            });
            el.addEventListener('mouseup', (e) => {
                if(e.button === 0) handleEnd(e);
            });
            // ç§»åŠ¨æ‰‹æŒ‡å–æ¶ˆæ“ä½œ
            el.addEventListener('touchmove', () => {
                if(longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            });
        }

        function handleClick(r, c) {
            const cell = grid[r][c];
            if (cell.isFlagged || cell.isOpen || !gameActive) return;

            if (isFirstClick) {
                placeMines(r, c);
                startTimer();
                isFirstClick = false;
            }

            openCell(r, c);
        }

        function toggleFlag(r, c) {
            const cell = grid[r][c];
            if (cell.isOpen || !gameActive) return;

            cell.isFlagged = !cell.isFlagged;
            cell.element.classList.toggle('flagged');
            cell.element.innerText = cell.isFlagged ? 'ğŸš©' : '';
            
            flags += cell.isFlagged ? -1 : 1;
            updateMineCount();
        }

        function placeMines(safeR, safeC) {
            const { rows, cols, mines } = CONFIG[currentDiff];
            let minesPlaced = 0;

            while (minesPlaced < mines) {
                const r = Math.floor(Math.random() * rows);
                const c = Math.floor(Math.random() * cols);

                // ä¿æŠ¤é¦–ç‚¹åŠå…¶å‘¨å›´ä¸€åœˆï¼Œä½“éªŒæ›´å¥½
                const isSafeZone = Math.abs(r - safeR) <= 1 && Math.abs(c - safeC) <= 1;

                if (!grid[r][c].isMine && !isSafeZone) {
                    grid[r][c].isMine = true;
                    minesPlaced++;
                }
            }

            // è®¡ç®—é‚»å±…
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (!grid[r][c].isMine) {
                        grid[r][c].neighbors = countNeighbors(r, c);
                    }
                }
            }
        }

        function countNeighbors(r, c) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (r + i >= 0 && r + i < CONFIG[currentDiff].rows &&
                        c + j >= 0 && c + j < CONFIG[currentDiff].cols) {
                        if (grid[r + i][c + j].isMine) count++;
                    }
                }
            }
            return count;
        }

        function openCell(r, c) {
            const cell = grid[r][c];
            if (cell.isOpen || cell.isFlagged) return;

            cell.isOpen = true;
            cell.element.classList.add('open');

            if (cell.isMine) {
                gameOver(false);
                cell.element.innerText = 'ğŸ·';
                cell.element.style.backgroundColor = '#ffcdd2';
                return;
            }

            if (cell.neighbors > 0) {
                cell.element.innerText = cell.neighbors;
                cell.element.classList.add(`c${cell.neighbors}`);
            } else {
                // Flood fill (é€’å½’æ‰“å¼€ç©ºç™½åŒºåŸŸ)
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const nr = r + i, nc = c + j;
                        if (nr >= 0 && nr < CONFIG[currentDiff].rows &&
                            nc >= 0 && nc < CONFIG[currentDiff].cols) {
                            openCell(nr, nc);
                        }
                    }
                }
            }

            checkWin();
        }

        function checkWin() {
            const { rows, cols, mines } = CONFIG[currentDiff];
            let openedCount = 0;
            
            grid.flat().forEach(cell => {
                if (cell.isOpen) openedCount++;
            });

            if (openedCount === (rows * cols - mines)) {
                gameOver(true);
            }
        }

        function gameOver(win) {
            gameActive = false;
            clearInterval(timerInterval);
            faceBtn.innerText = win ? 'ğŸ˜' : 'ğŸ˜µ';
            
            if (!win) {
                // æ˜¾ç¤ºæ‰€æœ‰çŒª
                grid.flat().forEach(cell => {
                    if (cell.isMine) {
                        cell.element.innerText = 'ğŸ·';
                        if (!cell.isOpen) cell.element.style.color = '#333';
                    } else if (cell.isFlagged) {
                        // æ ‡è®°é”™äº†
                        cell.element.innerText = 'âŒ';
                        cell.element.style.color = 'red';
                    }
                });
                if (navigator.vibrate) navigator.vibrate([100, 50, 100]); // å¤±è´¥é•¿éœ‡åŠ¨
            } else {
                // èƒœåˆ©é€»è¾‘ï¼šæŠŠå‰©ä¸‹çš„æ——å­æ’ä¸Š
                 grid.flat().forEach(cell => {
                    if (cell.isMine && !cell.isFlagged) {
                        cell.element.innerText = 'ğŸš©';
                        cell.element.classList.add('flagged');
                    }
                });
                flags = 0;
                updateMineCount();
            }

            // å»¶è¿Ÿæ˜¾ç¤ºå¼¹çª—
            setTimeout(() => {
                modalTitle.innerText = win ? "æ­å–œèƒœåˆ©ï¼ğŸ‰" : "å“å‘€ï¼Œè¸©åˆ°çŒªäº†ï¼";
                modalMsg.innerText = win ? `ç”¨æ—¶: ${time} ç§’` : "ä¸‹æ¬¡å°å¿ƒç‚¹å“¦~";
                overlay.classList.add('visible');
            }, 500);
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                time++;
                timerEl.innerText = time.toString().padStart(3, '0');
            }, 1000);
        }

        function updateMineCount() {
            mineCountEl.innerText = flags.toString().padStart(3, '0');
        }

        function showToast() {
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        // é¢éƒ¨æŒ‰é’®é‡ç½®
        faceBtn.onclick = resetGame;

        // å¯åŠ¨
        init();

    </script>
</body>
</html>
