<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ‰«ğŸ·</title>
    <style>
        :root {
            --bg-color: #fce4ec;
            --board-bg: #8d6e63;
            --cell-closed: #a1887f;
            --cell-open: #efebe9;
            --highlight: #f8bbd0;
            --text-color: #4e342e;
            --shadow-light: rgba(255, 255, 255, 0.3);
            --shadow-dark: rgba(0, 0, 0, 0.2);
            
            /* åŠ¨æ€å˜é‡ï¼Œç”±JSæ§åˆ¶ */
            --cell-size: 30px; 
            --cols: 9;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: "Varela Round", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh; /* å¼ºåˆ¶å æ»¡è§†å£ */
            height: 100dvh; /* æ›´å¥½çš„ç§»åŠ¨ç«¯é€‚é… */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* ç¦æ­¢bodyæ»šåŠ¨ */
        }

        /* é¡¶éƒ¨ä¿¡æ¯æ  - å›ºå®šé«˜åº¦ */
        header {
            flex: 0 0 auto; /* ä¸ä¼¸ç¼© */
            height: 70px;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .status-box { text-align: center; }
        .status-label { font-size: 11px; color: #888; margin-bottom: 2px;}
        .status-value { font-size: 20px; font-weight: 800; font-variant-numeric: tabular-nums; }

        .emoji-btn {
            font-size: 32px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .emoji-btn:active { transform: scale(0.85); }

        /* æ¸¸æˆä¸»åŒºåŸŸ - è‡ªé€‚åº”å‰©ä½™ç©ºé—´ */
        #game-container {
            flex: 1 1 auto; /* å æ®å‰©ä½™ç©ºé—´ */
            display: flex;
            justify-content: center;
            align-items: center; /* å‚ç›´å±…ä¸­ */
            overflow: hidden; /* é˜²æ­¢å†…éƒ¨æº¢å‡º */
            padding: 10px;
            width: 100%;
        }

        #grid {
            display: grid;
            /* æ ¸å¿ƒï¼šä½¿ç”¨CSSå˜é‡æ§åˆ¶åˆ—æ•°å’Œå¤§å° */
            grid-template-columns: repeat(var(--cols), var(--cell-size));
            gap: 2px;
            background-color: var(--board-bg);
            padding: 4px;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s; /* å°ºå¯¸å˜åŒ–æ—¶çš„è¿‡æ¸¡ */
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--cell-closed);
            border-radius: calc(var(--cell-size) * 0.1); /* åœ†è§’éšå¤§å°å˜åŒ– */
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            font-size: calc(var(--cell-size) * 0.6); /* å­—ä½“éšå¤§å°å˜åŒ– */
            cursor: pointer;
            box-shadow: inset 2px 2px 0 var(--shadow-light), inset -2px -2px 0 var(--shadow-dark);
        }

        .cell.open {
            background-color: var(--cell-open);
            box-shadow: none;
            border: 1px solid #d7ccc8;
        }
        
        .cell.flagged { font-size: calc(var(--cell-size) * 0.5); }

        /* æ•°å­—é¢œè‰² */
        .c1 { color: #1976D2; }
        .c2 { color: #388E3C; }
        .c3 { color: #D32F2F; }
        .c4 { color: #7B1FA2; }
        .c5 { color: #FF8F00; }
        .c6 { color: #0097A7; }
        .c7 { color: #424242; }
        .c8 { color: #8D6E63; }

        /* åº•éƒ¨æ§åˆ¶æ  - å›ºå®šé«˜åº¦ */
        footer {
            flex: 0 0 auto;
            height: 70px;
            padding: 0 10px;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .mode-btn {
            flex: 1;
            padding: 10px 0;
            border: 2px solid var(--board-bg);
            border-radius: 12px;
            background: transparent;
            color: var(--board-bg);
            font-weight: bold;
            font-size: 13px;
            max-width: 100px;
            white-space: nowrap;
        }

        .mode-btn.active {
            background: var(--board-bg);
            color: #fff;
        }

        /* å¼¹çª—é®ç½© */
        #overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(3px);
        }

        #overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: white;
            padding: 25px;
            border-radius: 16px;
            text-align: center;
            min-width: 260px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #overlay.visible .modal { transform: scale(1); }
        .restart-btn {
            background: var(--board-bg);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            margin-top: 15px;
        }
        
        /* æç¤ºå±‚ */
        .toast {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(62, 39, 35, 0.85);
            color: #fff;
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 13px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 50;
        }
        .toast.show { opacity: 1; }

    </style>
</head>
<body>

    <header id="header">
        <div class="status-box">
            <div class="status-label">ğŸ·</div>
            <div class="status-value" id="mine-count">000</div>
        </div>
        <div class="emoji-btn" id="face-btn">ğŸ˜Š</div>
        <div class="status-box">
            <div class="status-label">â±ï¸</div>
            <div class="status-value" id="timer">000</div>
        </div>
    </header>

    <div id="game-container">
        <div id="grid"></div>
    </div>

    <div class="toast" id="toast">é•¿æŒ‰æ’æ—— ğŸš© ç‚¹å‡»ç¿»å¼€</div>

    <footer id="footer">
        <button class="mode-btn active" onclick="setDifficulty('easy')">ç®€å•</button>
        <button class="mode-btn" onclick="setDifficulty('medium')">ä¸­ç­‰</button>
        <button class="mode-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
        <button class="mode-btn" onclick="setDifficulty('extreme')">åœ°ç‹±</button>
    </footer>

    <div id="overlay">
        <div class="modal">
            <h2 id="modal-title" style="margin:0 0 10px 0;"></h2>
            <p id="modal-msg" style="color:#666; margin:0;"></p>
            <button class="restart-btn" onclick="resetGame()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <script>
        // é…ç½®
        const CONFIG = {
            easy: { rows: 9, cols: 9, mines: 10 },
            medium: { rows: 12, cols: 12, mines: 20 },
            hard: { rows: 20, cols: 12, mines: 35 },     // é€‚åˆç«–å±
            extreme: { rows: 24, cols: 16, mines: 60 }   // é€‚åˆå¤§å±æˆ–å¹³æ¿
        };

        let currentDiff = 'easy';
        let grid = [];
        let gameActive = false;
        let flags = 0;
        let time = 0;
        let timerInterval;
        let isFirstClick = true;
        let longPressTimer;
        
        // DOM
        const gridEl = document.getElementById('grid');
        const containerEl = document.getElementById('game-container');
        const mineCountEl = document.getElementById('mine-count');
        const timerEl = document.getElementById('timer');
        const faceBtn = document.getElementById('face-btn');
        const overlay = document.getElementById('overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMsg = document.getElementById('modal-msg');

        function init() {
            window.oncontextmenu = (e) => { e.preventDefault(); return false; };
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', calculateLayout);
            setDifficulty('easy');
            showToast();
        }

        function setDifficulty(diff) {
            currentDiff = diff;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                // ç®€å•çš„æ–‡æœ¬åŒ¹é…é«˜äº®
                if(btn.onclick.toString().includes(diff)) btn.classList.add('active');
            });
            resetGame();
        }

        // æ ¸å¿ƒï¼šè‡ªé€‚åº”å¸ƒå±€è®¡ç®—
        function calculateLayout() {
            const { rows, cols } = CONFIG[currentDiff];
            
            // è·å–å®¹å™¨å®é™…å¯ç”¨å®½é«˜ (å‡å»å†…è¾¹è·)
            const availableW = containerEl.clientWidth - 20; // å·¦å³ç•™ç™½
            const availableH = containerEl.clientHeight - 20; // ä¸Šä¸‹ç•™ç™½
            
            // è®¡ç®—ä¸¤ç§æƒ…å†µä¸‹çš„æœ€å¤§å•å…ƒæ ¼å¤§å°
            const sizeByWidth = Math.floor(availableW / cols);
            const sizeByHeight = Math.floor(availableH / rows);
            
            // å–æœ€å°å€¼ï¼Œä¿è¯æ—¢ä¸è¶…å‡ºå®½ä¹Ÿä¸è¶…å‡ºé«˜
            let cellSize = Math.min(sizeByWidth, sizeByHeight);
            
            // é™åˆ¶æœ€å¤§å’Œæœ€å°å°ºå¯¸ï¼Œé˜²æ­¢è¿‡å¤§æˆ–è¿‡å°
            cellSize = Math.min(cellSize, 50); // æ¡Œé¢ç«¯ä¸è¦å¤ªå¤§
            cellSize = Math.max(cellSize, 22); // ç§»åŠ¨ç«¯ä¸è¦å¤ªå°ä»¥å…æŒ‰ä¸åˆ°
            
            // è®¾ç½® CSS å˜é‡
            gridEl.style.setProperty('--cols', cols);
            gridEl.style.setProperty('--cell-size', `${cellSize}px`);
        }

        function resetGame() {
            clearInterval(timerInterval);
            time = 0;
            timerEl.innerText = '000';
            gameActive = true;
            isFirstClick = true;
            faceBtn.innerText = 'ğŸ˜Š';
            overlay.classList.remove('visible');
            
            const { rows, cols, mines } = CONFIG[currentDiff];
            flags = mines;
            updateMineCount();

            // ç”ŸæˆDOMç»“æ„
            gridEl.innerHTML = '';
            grid = [];

            // å…ˆè®¡ç®—ä¸€æ¬¡å¸ƒå±€ï¼Œç¡®ä¿æ¸²æŸ“æ—¶å¤§å°æ­£ç¡®
            calculateLayout();

            for (let r = 0; r < rows; r++) {
                const row = [];
                for (let c = 0; c < cols; c++) {
                    const cell = {
                        r, c,
                        isMine: false, isOpen: false, isFlagged: false,
                        element: null, neighbors: 0
                    };
                    
                    const el = document.createElement('div');
                    el.className = 'cell';
                    // ä¸å†ç›´æ¥è®¾ç½®style.width/heightï¼Œç”±CSSå˜é‡æ§åˆ¶
                    
                    bindEvents(el, r, c);
                    cell.element = el;
                    row.push(cell);
                    gridEl.appendChild(el);
                }
                grid.push(row);
            }
        }

        function bindEvents(el, r, c) {
            const handleStart = (e) => {
                if (!gameActive || grid[r][c].isOpen) return;
                longPressTimer = setTimeout(() => {
                    toggleFlag(r, c);
                    longPressTimer = null;
                    if (navigator.vibrate) navigator.vibrate(50);
                }, 350); // ç¼©çŸ­é•¿æŒ‰æ—¶é—´ï¼Œæå‡æ‰‹æ„Ÿ
            };

            const handleEnd = (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    handleClick(r, c);
                }
                if(e.type === 'touchend') e.preventDefault();
            };

            el.addEventListener('touchstart', handleStart, {passive: false});
            el.addEventListener('touchend', handleEnd, {passive: false});
            el.addEventListener('mousedown', (e) => {
                if(e.button === 0) handleStart(e);
                if(e.button === 2) toggleFlag(r, c);
            });
            el.addEventListener('mouseup', (e) => {
                if(e.button === 0) handleEnd(e);
            });
            el.addEventListener('touchmove', () => {
                if(longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
            });
        }

        function handleClick(r, c) {
            const cell = grid[r][c];
            if (cell.isFlagged || cell.isOpen || !gameActive) return;

            if (isFirstClick) {
                placeMines(r, c);
                startTimer();
                isFirstClick = false;
            }
            openCell(r, c);
        }

        function toggleFlag(r, c) {
            const cell = grid[r][c];
            if (cell.isOpen || !gameActive) return;
            cell.isFlagged = !cell.isFlagged;
            cell.element.classList.toggle('flagged');
            cell.element.innerText = cell.isFlagged ? 'ğŸš©' : '';
            flags += cell.isFlagged ? -1 : 1;
            updateMineCount();
        }

        function placeMines(safeR, safeC) {
            const { rows, cols, mines } = CONFIG[currentDiff];
            let minesPlaced = 0;
            while (minesPlaced < mines) {
                const r = Math.floor(Math.random() * rows);
                const c = Math.floor(Math.random() * cols);
                const isSafeZone = Math.abs(r - safeR) <= 1 && Math.abs(c - safeC) <= 1;
                if (!grid[r][c].isMine && !isSafeZone) {
                    grid[r][c].isMine = true;
                    minesPlaced++;
                }
            }
            // è®¡ç®—é‚»å±…
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (!grid[r][c].isMine) grid[r][c].neighbors = countNeighbors(r, c);
                }
            }
        }

        function countNeighbors(r, c) {
            let count = 0;
            const { rows, cols } = CONFIG[currentDiff];
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const nr = r + i, nc = c + j;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        if (grid[nr][nc].isMine) count++;
                    }
                }
            }
            return count;
        }

        function openCell(r, c) {
            const cell = grid[r][c];
            if (cell.isOpen || cell.isFlagged) return;
            cell.isOpen = true;
            cell.element.classList.add('open');

            if (cell.isMine) {
                gameOver(false);
                cell.element.innerText = 'ğŸ·';
                cell.element.style.backgroundColor = '#ffcdd2';
                return;
            }

            if (cell.neighbors > 0) {
                cell.element.innerText = cell.neighbors;
                cell.element.classList.add(`c${cell.neighbors}`);
            } else {
                const { rows, cols } = CONFIG[currentDiff];
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const nr = r + i, nc = c + j;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) openCell(nr, nc);
                    }
                }
            }
            checkWin();
        }

        function checkWin() {
            const { rows, cols, mines } = CONFIG[currentDiff];
            let openedCount = 0;
            grid.flat().forEach(cell => { if (cell.isOpen) openedCount++; });
            if (openedCount === (rows * cols - mines)) gameOver(true);
        }

        function gameOver(win) {
            gameActive = false;
            clearInterval(timerInterval);
            faceBtn.innerText = win ? 'ğŸ˜' : 'ğŸ˜µ';
            if (!win) {
                grid.flat().forEach(cell => {
                    if (cell.isMine) {
                        cell.element.innerText = 'ğŸ·';
                        if (!cell.isOpen) cell.element.style.color = '#333';
                    } else if(cell.isFlagged) {
                        cell.element.innerText = 'âŒ';
                    }
                });
                if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
            } else {
                 grid.flat().forEach(cell => {
                    if (cell.isMine && !cell.isFlagged) {
                        cell.element.innerText = 'ğŸš©';
                        cell.element.classList.add('flagged');
                    }
                });
            }
            setTimeout(() => {
                modalTitle.innerText = win ? "æ­å–œèƒœåˆ©ï¼ğŸ‰" : "å“å‘€ï¼Œè¸©åˆ°çŒªäº†ï¼";
                modalMsg.innerText = win ? `ç”¨æ—¶: ${time} ç§’` : "ä¸‹æ¬¡å°å¿ƒç‚¹å“¦~";
                overlay.classList.add('visible');
            }, 600);
        }

        function startTimer() {
            timerInterval = setInterval(() => { time++; timerEl.innerText = time.toString().padStart(3, '0'); }, 1000);
        }
        function updateMineCount() { mineCountEl.innerText = flags.toString().padStart(3, '0'); }
        function showToast() {
            const t = document.getElementById('toast');
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        faceBtn.onclick = resetGame;
        init();

    </script>
</body>
</html>
