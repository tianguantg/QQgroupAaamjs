<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Êâ´üê∑</title>
    <style>
        :root {
            --bg-color: #fce4ec;
            --board-bg: #8d6e63;
            --cell-closed: #a1887f;
            --cell-open: #efebe9;
            --highlight: #f8bbd0;
            --text-color: #4e342e;
            --shadow-light: rgba(255, 255, 255, 0.3);
            --shadow-dark: rgba(0, 0, 0, 0.2);
            --cell-size: 30px;
            --cols: 9;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            height: 100dvh; 
            width: 100vw;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- È°∂ÈÉ®‰ø°ÊÅØÊ†è --- */
        header {
            flex-shrink: 0;
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            z-index: 10;
            min-height: 50px;
        }

        .status-box { text-align: center; font-weight: bold; min-width: 60px; }
        .status-label { font-size: 10px; color: #888; margin-bottom: 2px; }
        .status-value { font-size: 18px; font-family: monospace; }
        
        .emoji-btn {
            font-size: 24px;
            cursor: pointer;
            width: 36px; height: 36px;
            display: flex; justify-content: center; align-items: center;
            border-radius: 50%;
            background: #f5f5f5;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .emoji-btn:active { transform: scale(0.9); background: #eee; }

        /* --- Ê∏∏Êàè‰∏ªÂå∫Âüü --- */
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 6px;
            overflow: hidden;
            position: relative;
            min-height: 0; /* ÂÖ≥ÈîÆÔºöÂÖÅËÆ∏flexÂ≠êÈ°πÁº©Â∞è */
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(var(--cols), var(--cell-size));
            gap: 2px;
            background-color: var(--board-bg);
            padding: 4px;
            border-radius: 6px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--cell-closed);
            border-radius: 2px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            font-size: calc(var(--cell-size) * 0.6); 
            cursor: pointer;
            box-shadow: inset 2px 2px 0 var(--shadow-light), inset -2px -2px 0 var(--shadow-dark);
        }

        .cell.open {
            background-color: var(--cell-open);
            box-shadow: none;
            border: 1px solid #d7ccc8;
        }
        
        .cell.flagged { font-size: calc(var(--cell-size) * 0.5); }

        /* Êï∞Â≠óÈ¢úËâ≤ */
        .c1 { color: #1976D2; } .c2 { color: #388E3C; } .c3 { color: #D32F2F; }
        .c4 { color: #7B1FA2; } .c5 { color: #FF8F00; } .c6 { color: #0097A7; }
        .c7 { color: #424242; } .c8 { color: #8D6E63; }

        /* --- Â∫ïÈÉ®ÊéßÂà∂Ê†è --- */
        footer {
            flex-shrink: 0;
            padding: 8px 15px;
            background: #fff;
            display: flex;
            justify-content: space-around;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
            padding-bottom: max(8px, env(safe-area-inset-bottom));
        }

        .mode-btn {
            padding: 5px 10px;
            border: 1px solid var(--board-bg);
            border-radius: 15px;
            background: transparent;
            color: var(--board-bg);
            font-weight: bold;
            font-size: 12px;
            white-space: nowrap;
        }

        .mode-btn.active {
            background: var(--board-bg);
            color: #fff;
            box-shadow: 0 2px 6px rgba(141, 110, 99, 0.4);
        }

        /* --- ÂºπÁ™ó‰∏éÊèêÁ§∫ --- */
        #overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(2px);
        }

        #overlay.visible { opacity: 1; pointer-events: auto; }

        .modal {
            background: white;
            padding: 25px;
            border-radius: 16px;
            text-align: center;
            width: 75%;
            max-width: 300px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transform: scale(0.9);
            transition: transform 0.3s;
        }
        #overlay.visible .modal { transform: scale(1); }

        .restart-btn {
            background: var(--board-bg);
            color: white; border: none; padding: 10px 24px;
            border-radius: 20px; font-size: 16px; font-weight: bold;
            margin-top: 15px;
        }
        
        .toast {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 50;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

    <header>
        <div class="status-box">
            <div class="status-label">Áå™Áå™</div>
            <div class="status-value" id="mine-count">000</div>
        </div>
        <div class="emoji-btn" id="face-btn">üòä</div>
        <div class="status-box">
            <div class="status-label">ËÄóÊó∂</div>
            <div class="status-value" id="timer">000</div>
        </div>
    </header>

    <div id="game-container">
        <div id="grid"></div>
    </div>

    <div class="toast" id="toast">ÈïøÊåâÊñπÂùóÊèíÊóó üö©</div>

    <footer>
        <button class="mode-btn" onclick="setDifficulty('easy')">ÁÆÄÂçï</button>
        <button class="mode-btn" onclick="setDifficulty('medium')">‰∏≠Á≠â</button>
        <button class="mode-btn" onclick="setDifficulty('hard')">Âõ∞Èöæ</button>
    </footer>

    <div id="overlay">
        <div class="modal">
            <h2 id="modal-title" style="margin:0 0 10px 0;">ÁªìÊùü</h2>
            <p id="modal-msg" style="color:#666; margin:0;">...</p>
            <button class="restart-btn" onclick="resetGame()">ÂÜçÁé©‰∏ÄÊ¨°</button>
        </div>
    </div>

    <script>
        // Ê∏∏ÊàèÈÖçÁΩÆ
        const CONFIG = {
            easy: { rows: 9, cols: 9, mines: 10 },
            medium: { rows: 12, cols: 12, mines: 20 },
            hard: { rows: 20, cols: 12, mines: 35 }
        };

        // Áä∂ÊÄÅÂèòÈáè
        let currentDiff = 'easy';
        let gridData = [];
        let gameActive = false;
        let flags = 0;
        let time = 0;
        let timerInterval;
        let isFirstClick = true;
        let longPressTimer;

        // DOM ÂÖÉÁ¥†
        const gridEl = document.getElementById('grid');
        const containerEl = document.getElementById('game-container');
        const mineCountEl = document.getElementById('mine-count');
        const timerEl = document.getElementById('timer');
        const faceBtn = document.getElementById('face-btn');
        const overlay = document.getElementById('overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMsg = document.getElementById('modal-msg');

        // ÂàùÂßãÂåñ
        function init() {
            window.oncontextmenu = (e) => {
                e.preventDefault();
                return false;
            };
            
            window.addEventListener('resize', calculateGridSize);
            
            setDifficulty('easy');
            showToast();
        }

        // ÂàáÊç¢ÈöæÂ∫¶
        function setDifficulty(diff) {
            currentDiff = diff;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
                if(btn.onclick.toString().includes(diff)) btn.classList.add('active');
            });
            resetGame();
        }

        // Ê†∏ÂøÉÔºöËÆ°ÁÆóÁΩëÊ†ºÂ∞∫ÂØ∏Ôºà‰øÆÂ§çÁâàÔºâ
        function calculateGridSize() {
            if (!containerEl) return;
            
            const { rows, cols } = CONFIG[currentDiff];
            
            // Ëé∑ÂèñÂÆπÂô®ÂÆûÈôÖÂèØÁî®Á©∫Èó¥
            const containerRect = containerEl.getBoundingClientRect();
            const containerPadding = 12; // ÂÆπÂô®padding (6px * 2)
            const gridPadding = 8; // ÁΩëÊ†ºpadding (4px * 2)
            const gapTotal = (rows - 1) * 2; // Ë°åÈó¥ÈöôÊÄªÂíå (gap: 2px)
            const gapTotalCols = (cols - 1) * 2; // ÂàóÈó¥ÈöôÊÄªÂíå
            
            // ÂÆûÈôÖÂèØÁî®‰∫éÊîæÁΩÆÊ†ºÂ≠êÁöÑÁ©∫Èó¥
            const availableWidth = containerRect.width - containerPadding - gridPadding - gapTotalCols;
            const availableHeight = containerRect.height - containerPadding - gridPadding - gapTotal;

            // ËÆ°ÁÆóÂçïÂÖÉÊ†ºÂ§ßÂ∞è
            const sizeByWidth = Math.floor(availableWidth / cols);
            const sizeByHeight = Math.floor(availableHeight / rows);

            // ÂèñËæÉÂ∞èÂÄºÔºåÈôêÂà∂ÊúÄÂ§ß45pxÔºåÊúÄÂ∞è18px
            const finalSize = Math.max(18, Math.min(sizeByWidth, sizeByHeight, 45));

            // Êõ¥Êñ∞ CSS ÂèòÈáè
            document.documentElement.style.setProperty('--cell-size', `${finalSize}px`);
            document.documentElement.style.setProperty('--cols', cols);
        }

        // ÈáçÁΩÆÊ∏∏Êàè
        function resetGame() {
            clearInterval(timerInterval);
            time = 0;
            timerEl.innerText = '000';
            gameActive = true;
            isFirstClick = true;
            faceBtn.innerText = 'üòä';
            overlay.classList.remove('visible');
            
            const { rows, cols, mines } = CONFIG[currentDiff];
            flags = mines;
            updateMineCount();

            // ÂÖàÊ∏ÖÁ©∫ÂÜçËÆ°ÁÆóÂ∞∫ÂØ∏
            gridEl.innerHTML = '';
            gridData = [];
            
            // Âª∂Ëøü‰∏ÄÂ∏ßÁ°Æ‰øùÂÆπÂô®Â∞∫ÂØ∏Ê≠£Á°Æ
            requestAnimationFrame(() => {
                calculateGridSize();
                
                // ÁîüÊàêÊ†ºÂ≠ê
                for (let r = 0; r < rows; r++) {
                    const row = [];
                    for (let c = 0; c < cols; c++) {
                        const cellData = {
                            r, c,
                            isMine: false, isOpen: false, isFlagged: false,
                            element: null, neighbors: 0
                        };
                        
                        const el = document.createElement('div');
                        el.className = 'cell';
                        
                        bindEvents(el, r, c);
                        
                        cellData.element = el;
                        row.push(cellData);
                        gridEl.appendChild(el);
                    }
                    gridData.push(row);
                }
            });
        }

        // ÁªëÂÆö‰∫ã‰ª∂
        function bindEvents(el, r, c) {
            const handleStart = (e) => {
                if (!gameActive || gridData[r][c].isOpen) return;
                longPressTimer = setTimeout(() => {
                    toggleFlag(r, c);
                    longPressTimer = null;
                    if (navigator.vibrate) navigator.vibrate(50);
                }, 350);
            };

            const handleEnd = (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    handleClick(r, c);
                }
            };

            el.addEventListener('touchstart', handleStart, {passive: true});
            el.addEventListener('touchend', (e) => {
                e.preventDefault();
                handleEnd(e);
            }, {passive: false});

            el.addEventListener('mousedown', (e) => {
                if(e.button === 0) handleStart(e);
                if(e.button === 2) toggleFlag(r, c);
            });
            el.addEventListener('mouseup', (e) => {
                if(e.button === 0) handleEnd(e);
            });
            el.addEventListener('touchmove', () => {
                if(longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
            });
        }

        // ÁÇπÂáªÈÄªËæë
        function handleClick(r, c) {
            const cell = gridData[r][c];
            if (cell.isFlagged || cell.isOpen || !gameActive) return;

            if (isFirstClick) {
                placeMines(r, c);
                startTimer();
                isFirstClick = false;
            }
            openCell(r, c);
        }

        // ÊèíÊóóÈÄªËæë
        function toggleFlag(r, c) {
            const cell = gridData[r][c];
            if (cell.isOpen || !gameActive) return;

            cell.isFlagged = !cell.isFlagged;
            cell.element.classList.toggle('flagged');
            cell.element.innerText = cell.isFlagged ? 'üö©' : '';
            
            flags += cell.isFlagged ? -1 : 1;
            updateMineCount();
        }

        // Â∏ÉÈõ∑ÈÄªËæë
        function placeMines(safeR, safeC) {
            const { rows, cols, mines } = CONFIG[currentDiff];
            let placed = 0;
            while (placed < mines) {
                const r = Math.floor(Math.random() * rows);
                const c = Math.floor(Math.random() * cols);
                if (!gridData[r][c].isMine && (Math.abs(r - safeR) > 1 || Math.abs(c - safeC) > 1)) {
                    gridData[r][c].isMine = true;
                    placed++;
                }
            }
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    if(!gridData[r][c].isMine) gridData[r][c].neighbors = countNeighbors(r, c);
                }
            }
        }

        function countNeighbors(r, c) {
            let count = 0;
            const { rows, cols } = CONFIG[currentDiff];
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const nr = r + i, nc = c + j;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && gridData[nr][nc].isMine) count++;
                }
            }
            return count;
        }

        // ÈÄíÂΩíÊâìÂºÄ
        function openCell(r, c) {
            const cell = gridData[r][c];
            if (cell.isOpen || cell.isFlagged) return;

            cell.isOpen = true;
            cell.element.classList.add('open');

            if (cell.isMine) {
                gameOver(false);
                cell.element.innerText = 'üê∑';
                cell.element.style.backgroundColor = '#ef9a9a';
                return;
            }

            if (cell.neighbors > 0) {
                cell.element.innerText = cell.neighbors;
                cell.element.classList.add(`c${cell.neighbors}`);
            } else {
                const { rows, cols } = CONFIG[currentDiff];
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const nr = r + i, nc = c + j;
                        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) openCell(nr, nc);
                    }
                }
            }
            checkWin();
        }

        function checkWin() {
            const { rows, cols, mines } = CONFIG[currentDiff];
            const opened = gridData.flat().filter(c => c.isOpen).length;
            if (opened === rows * cols - mines) gameOver(true);
        }

        function gameOver(win) {
            gameActive = false;
            clearInterval(timerInterval);
            faceBtn.innerText = win ? 'üòé' : 'üòµ';
            
            if (!win) {
                gridData.flat().forEach(cell => {
                    if (cell.isMine) {
                        cell.element.innerText = 'üê∑';
                        if (!cell.isOpen) cell.element.style.color = '#555';
                    } else if (cell.isFlagged) {
                        cell.element.innerText = '‚ùå';
                        cell.element.style.color = 'red';
                    }
                });
                if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
            } else {
                flags = 0;
                updateMineCount();
            }

            setTimeout(() => {
                modalTitle.innerText = win ? "Â§ßËé∑ÂÖ®ËÉúÔºÅüéâ" : "Ë¢´Áå™Áå™ÂèëÁé∞‰∫ÜÔºÅ";
                modalMsg.innerText = win ? `ËÄóÊó∂: ${time} Áßí` : "ÂÜçÊé•ÂÜçÂéâ";
                overlay.classList.add('visible');
            }, 600);
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                time++;
                timerEl.innerText = time.toString().padStart(3, '0');
            }, 1000);
        }

        function updateMineCount() {
            mineCountEl.innerText = flags.toString().padStart(3, '0');
        }

        function showToast() {
            const t = document.getElementById('toast');
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        faceBtn.onclick = resetGame;

        init();

    </script>
</body>
</html>
